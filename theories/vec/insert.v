(**************************************************************)
(*   Copyright Dominique Larchey-Wendling [*]                 *)
(*                                                            *)
(*                             [*] Affiliation LORIA -- CNRS  *)
(**************************************************************)
(*      This file is distributed under the terms of the       *)
(*        Mozilla Public License Version 2.0, MPL-2.0         *)
(**************************************************************)

From Coq
  Require Import Arith Lia Utf8.

From KruskalTrees
  Require Import idx vec.

From KruskalFinite
  Require Import finite.

Require Import base notations tactics app.

Import idx_notations vec_notations.

Set Implicit Arguments.

(* ùïÜùïä Œª ‚àÄ‚àÉ ‚Üí ‚Üî ‚àß ‚à® *)

#[global] Reserved Notation "v '‚ä≤' p ']' x '‚áù' w" (at level 70, x at level 200, no associativity, format "v ‚ä≤ p ] x  ‚áù  w").

Inductive vinsert_graph X x : forall n, vec X n ‚Üí idx (S n) ‚Üí forall m, vec X m ‚Üí Prop :=
  | in_vec_insert_gr_0 n (v : vec _ n) : v ‚ä≤ùïÜ] x ‚áù x##v
  | in_vec_insert_gr_1 n y (v : vec _ n) p m (w : vec _ m) : v ‚ä≤p] x ‚áù w -> y##v ‚ä≤ùïä p] x ‚áù y##w
where "v ‚ä≤ p ] x ‚áù w" := (@vinsert_graph _ x _ v p _ w).

#[global] Hint Constructors vinsert_graph : core.

Section vinsert.

  Variable (X : Type).

  Implicit Types (x : X).

  Fact vinsert_length x n (v : vec _ n) p m (w : vec _ m) : v ‚ä≤p] x ‚áù w ‚Üí m = S n.
  Proof. induction 1; auto. Qed.

  Fact vinsert_inv x n (v : vec _ n) p m (w : vec _ m) :
          v ‚ä≤p] x ‚áù w
        ‚Üí match idx_S_inv p with
          | None   => ‚àÉe, w‚Ü∫e = x##v
          | Some q =>
            match n return vec _ n ‚Üí idx n ‚Üí _ with
            | 0   => ‚ä•‚ÇÇ
            | S n => Œª v q,
              match w with
              | ‚àÖ    => False
              | y##w => vec_tail v ‚ä≤q] x ‚áù w ‚àß vec_head v = y
              end
            end v q
          end.
  Proof. induction 1; simpl; eauto; exists eq_refl; auto. Qed.

  Fact vinsert_left_inv_0 x n (v : vec _ n) (w : vec _ (S n)) : v ‚ä≤ùïÜ] x ‚áù w -> w = x##v.
  Proof.
    intros H.
    apply vinsert_inv in H as (e & H); eq refl; auto.
  Qed.

  Fact vinsert_left_inv_1 x n y (v : vec _ n) p m (w : vec _ m) :
         y##v ‚ä≤ùïä p] x ‚áù w
       ‚Üí match w with
         | ‚àÖ    => False
         | z##w => v ‚ä≤p] x ‚áù w ‚àß y = z
         end.
  Proof. intros H; now apply vinsert_inv in H; simpl in H. Qed.

  Fact vinsert_fun x n (v : vec _ n) p m1 (w1 : vec _ m1) m2 (w2 : vec _ m2) :
          v ‚ä≤p] x ‚áù w1 ‚Üí v ‚ä≤p] x ‚áù w2 ‚Üí exists e, w1‚Ü∫e = w2.
  Proof.
    intros H; revert H m2 w2.
    induction 1 as [ n v | n y v p m1 w1 H1 IH1 ]; intros m2 w2 H2; apply vinsert_inv in H2; simpl in H2.
    + destruct H2 as (e & H2); eq refl; exists eq_refl; auto.
    + destruct w2 as [ | m2 z w2 ]; try easy; destruct H2 as [ H2 <- ].
      apply IH1 in H2 as (e & H3); eq refl; subst; exists eq_refl; auto.
  Qed.

  Inductive vinsert_out : Type :=
    | c_vinsert_out m : vec X m -> vinsert_out.

  Definition is_vinsert_out x n (v : vec _ n) p o :=
    match o with c_vinsert_out w => v ‚ä≤p] x ‚áù w end.

  Fact vinsert_total x n v p : sig (@is_vinsert_out x n v p).
  Proof.
    revert p.
    induction v as [ | y n v IHv ]; intros p; idx invert p.
    + exists (c_vinsert_out (x##‚àÖ)); simpl; auto.
    + idx invert p.
    + exists (c_vinsert_out (x##y##v)); simpl; auto.
    + destruct (IHv p) as ([m w] & Hw); simpl in Hw.
      exists (c_vinsert_out (y##w)); simpl; auto.
  Qed.

  Inductive vinsert_in : Type :=
    | c_vinsert_in (_ : X) n : vec X n ‚Üí idx (S n) ‚Üí vinsert_in.

  Definition is_vinsert_in m (w : vec _ m) i :=
    match i with @c_vinsert_in x n v p => v ‚ä≤p] x ‚áù w end.

  Fact vinsert_surj m (w : vec X m) : ‚àÄp, { n : _ & { v : _ & { e : m = S n | v ‚ä≤p‚Ü∫e] w‚¶Ép‚¶Ñ ‚áù w } } }.
  Proof.
    induction w as [ | x m v IHv ]; intros p; idx invert p.
    + exists m, v, eq_refl; simpl; auto.
    + destruct (IHv p) as (n & w & -> & H); simpl in *.
      exists (S n), (x##w), eq_refl; simpl; auto.
  Qed.

  Fact is_vinsert_in_nil_iff i : is_vinsert_in ‚àÖ i ‚Üî False.
  Proof.
    split; try easy.
    destruct i as [ x n v p ]; simpl; intros H.
    apply vinsert_inv in H; idx invert p; simpl in H.
    + destruct H as (e & _); lia.
    + destruct n; simpl in H; auto.
  Qed.

  Fact is_vinsert_in_cons_iff m y w i :
          @is_vinsert_in (S m) (y##w) i
        ‚Üî c_vinsert_in y w ùïÜ = i
        ‚à® ‚àÉi', match i' with
               | @c_vinsert_in x n v p => c_vinsert_in x (y##v) (ùïä p)
               end = i
             ‚àß is_vinsert_in w i'.
  Proof.
    split.
    + destruct i as [ x n v p ]; simpl; intros H.
      apply vinsert_inv in H; idx invert p; simpl in H.
      * destruct H as (e & H); inversion e; subst; eq refl.
        apply vec_cons_inj in H as (-> & ->); auto.
      * destruct v as [ | z n v ]; try easy; simpl in H.
        destruct H as [ H -> ]; right.
        exists (c_vinsert_in x v p); split; auto.
    + intros [ <- | ([x n v p] & H1 & H2) ]; subst; simpl in *; auto.
  Qed.

  Fact vinsert_fin m w : fin (@is_vinsert_in m w).
  Proof.
    induction w as [ | y m w IHw ].
    + finite eq is_vinsert_in_nil_iff.
    + finite eq (is_vinsert_in_cons_iff _ _).
  Qed.

  Fact vinsert_fall (P : X ‚Üí Prop) x n (v : vec _ n) p m (w : vec _ m) :
         v ‚ä≤p] x ‚áù w ‚Üí P x ‚àß vec_fall P v ‚Üî vec_fall P w.
  Proof. induction 1; rewrite !vec_fall_cons_iff; tauto. Qed.

End vinsert.

Section vinsert_idx.

  (* This computes the index of an insertion *)

  Let Fixpoint vins_idx n (p : idx n) : idx (S n) ‚Üí idx (S n) :=
    match p with
    | ùïÜ => Œª q,
      match idx_S_inv q with
      | Some _ => idx‚ÇÄ
      | None   => idx‚ÇÅ
      end
    | ùïä p' as p => Œª q,
      match idx_S_inv q with
      | Some q => ùïä (vins_idx p' q)
      | None   => ùïä p
      end
    end.

  Local Fact vins_surj n q k : { p : idx n | k = @vins_idx _ p q } + { k = q }.
  Proof.
    revert q k.
    induction n as [ | n IHn ]; intros q k;
      idx invert q; idx invert k; simpl; auto; try (idx invert all; fail).
    + left; exists k; simpl; idx invert k; auto.
    + left; exists idx‚ÇÄ; auto.
    + destruct (IHn q k) as [ (p & Hp) | -> ]; auto.
      left; exists (idx_nxt p); simpl; f_equal; auto.
  Qed.

  Definition vinsert_idx n p q := @vins_idx n q p.

  Fact vinsert_idx_surj n p q : { q' | q = @vinsert_idx n p q' } + { q = p }.
  Proof. apply vins_surj. Qed.

  Variables (X : Type) (x : X).

  Local Fact vins_idx_spec n (v : vec _ n) p m (w : vec _ m) :
      v ‚ä≤p] x ‚áù w ‚Üí ‚àÄ (e : m = S n) q, v‚¶Éq‚¶Ñ = (w‚Ü∫e)‚¶Évins_idx q p‚¶Ñ.
  Proof.
    induction 1 as [ n v | n y v p m w H1 IH1 ]; intros e q.
    + destruct q; eq refl; simpl; auto.
    + inversion e; subst; eq refl; idx invert q; auto.
      apply (IH1 eq_refl).
  Qed.

  Local Fact vinsert_eq_rec n (v : vec _ n) p m (w : vec _ m) :
        v ‚ä≤p] x ‚áù w ‚Üí ‚àÄ (e : m = S n), (w‚Ü∫e)‚¶Ép‚¶Ñ = x.
  Proof.
    induction 1 as [ n v | n y v p m w H1 IH1 ]; intro e; eq refl; auto.
    inversion e; subst; eq refl.
    apply (IH1 eq_refl).
  Qed.

  Fact vinsert_eq n (v : vec _ n) p w : v ‚ä≤p] x ‚áù w ‚Üí w‚¶Ép‚¶Ñ = x.
  Proof. intros H; apply vinsert_eq_rec with (1 := H) (e := eq_refl). Qed.

  Theorem vinsert_idx_eq n (v : vec _ n) p w :
         v ‚ä≤p] x ‚áù w ‚Üî w‚¶Ép‚¶Ñ = x ‚àß ‚àÄq, v‚¶Éq‚¶Ñ = w‚¶Évinsert_idx p q‚¶Ñ.
  Proof.
    split.
    + intros H; split.
      * eapply vinsert_eq; eauto.
      * apply vins_idx_spec with (1 := H) (e := eq_refl).
    + intros (<- & H).
       assert (v = vec_set (fun q => vec_prj w (vinsert_idx p q))) as ->.
       1: now vec ext; vec rew.
       clear H.
       revert p w; induction n as [ | n IHn ]; intros p w;
         vec invert w as x w; idx invert p; auto.
       * vec invert w; auto.
       * idx invert p.
       * vec invert w as y w; simpl; rewrite vec_set_prj; auto.
  Qed.

  Fact vinsert_prj n (v : vec _ n) p w :
         v ‚ä≤p] x ‚áù w ‚Üí ‚àÄi, (i = p ‚àß w‚¶Éi‚¶Ñ = x) ‚à® (‚àÉj, w‚¶Éi‚¶Ñ = v‚¶Éj‚¶Ñ).
  Proof.
    intros (H1 & H2)%vinsert_idx_eq i.
    destruct (vinsert_idx_surj p i) as [ (q & ->) | -> ].
    + right; eauto.
    + left; eauto.
  Qed.

End vinsert_idx.

Fact vinsert_surjective X n (v : vec X (S n)) (p : idx (S n)) :
     { u : vec _ n | u ‚ä≤p] v‚¶Ép‚¶Ñ ‚áù v ‚àß ‚àÄq, u‚¶Éq‚¶Ñ = v‚¶Évinsert_idx p q‚¶Ñ }.
Proof.
  destruct (vinsert_surj v p) as (i & w & e & H).
  inversion e; subst; eq refl.
  exists w; split; auto.
  rewrite vinsert_idx_eq in H; tauto.
Qed.

#[local] Notation "u '=[' R ']=' v" := (vec_fall2 R u v) (at level 70, format "u  =[ R ]=  v").

Section vinsert_fall2.

  Variables (X Y : Type) (R : X ‚Üí Y ‚Üí Prop).

  Fact vinsert_fall2 x y n (v v' : vec _ n) p m (w w' : vec _ m) :
         v‚ä≤p]x ‚áù w
      ‚Üí v'‚ä≤p]y ‚áù w'
      ‚Üí w =[R]= w' ‚Üî R x y ‚àß v =[R]= v'.
  Proof.
    intros H1 H2.
    generalize (vinsert_length H1); intros ->.
    apply vinsert_idx_eq in H1 as (<- & H1).
    apply vinsert_idx_eq in H2 as (<- & H2).
    split.
    + intros H; split; auto.
      intro; rewrite H1, H2; auto.
    + intros (H3 & H4) q.
      destruct (vinsert_idx_surj p q) as [ (q' & ->) | -> ]; auto.
      rewrite <- H1, <- H2; auto.
  Qed.

  Fact vinsert_fall2_inv x n (v : vec _ n) p m (w w' : vec _ m) :
         v‚ä≤p]x ‚áù w
       ‚Üí w =[R]= w'
       ‚Üí { y : _ &
         { v' : _ | v'‚ä≤p]y ‚áù w'
                  ‚àß R x y
                  ‚àß v =[R]= v' } }.
  Proof.
    intros H1 H2.
    generalize (vinsert_length H1); intros ->.
    apply vinsert_idx_eq in H1 as (<- & H1).
    exists (vec_prj w' p), (vec_set (fun q => vec_prj w' (vinsert_idx p q))); rsplit 2; auto.
    + apply vinsert_idx_eq; split; auto.
      intros q; rewrite vec_prj_set; auto.
    + intro; rewrite vec_prj_set, H1; auto.
  Qed.

End vinsert_fall2.

Section vec_insert_fall2.

  Variables (X Y : Type) (R : X ‚Üí Y ‚Üí Prop) (n : nat)
            (u : vec X (S n)) (v : vec Y (S n)).

  Theorem vinsert_any_vec_fall2 :
        (‚àÄ w q x, w ‚ä≤q] x ‚áù v ‚Üí R u‚¶Éq‚¶Ñ x) ‚Üí u =[R]= v.
  Proof.
    intros H p.
    destruct (vinsert_surj v p) as (i & v' & e & Hv').
    inversion e; subst i; eq refl.
    apply H with (1 := Hv').
  Qed.

  Theorem vec_fall2_any_vinsert :
       u =[R]= v ‚Üí ‚àÄ w q x, w ‚ä≤q] x ‚áù v ‚Üí R u‚¶Éq‚¶Ñ x.
  Proof. intros ? ? ? ? (<- & _)%vinsert_idx_eq; auto. Qed.

  (** This is a charaterization of vec_fall2 in terms of
      analysis using insertion/extraction of a value in v.

      This can be compared to exceptional_iff_embed in
      KruskalHigman af/af_utree_embed_[fun,rel].v 

      See also vec_embed_iff_vintercal in vec_rel/rel/intercal.v *)

  Theorem vec_fall2_iff_vinsert : 
       u =[R]= v ‚Üî ‚àÄ w q x, w ‚ä≤q] x ‚áù v ‚Üí R u‚¶Éq‚¶Ñ x.
  Proof.
    split.
    + apply vec_fall2_any_vinsert.
    + apply vinsert_any_vec_fall2.
  Qed.

End vec_insert_fall2.

